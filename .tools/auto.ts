import { walk } from "std/fs/walk.ts";

const autogeneratedNotice = "/* Autogenerated by /.tools/auto.ts */\n";

// todo: add support for getters

async function loadTypeNamesByMethodName() {
  const result = new Map<string, Set<string>>();
  const regExp = /^(?<typeName>[^/]+)\/methods\/(?<methodName>[^./]+)\.ts$/;
  for await (const entry of walk(".", { match: [regExp] })) {
    const { typeName, methodName } = regExp.exec(entry.path)!.groups!;
    if (typeName.startsWith(".")) continue;
    if (!result.has(methodName)) result.set(methodName, new Set());
    result.get(methodName)!.add(typeName);
  }
  return result;
}

async function updateTextFile(path: string | URL, data: string) {
  try {
    if (data !== await Deno.readTextFile(path)) {
      await Deno.writeTextFile(path, data);
    }
  } catch {
    await Deno.writeTextFile(path, data);
  }
}

async function writeSymbolFiles(
  typeNamesByMethodName: Map<string, Set<string>>,
) {
  function symbolFileData(methodName: string, typeNames: string[]) {
    function seeCommentBlockLines() {
      return typeNames
        .map((typeName) => ` * @see ./${typeName}/${methodName}.ts`)
        .join("\n");
    }

    return `${autogeneratedNotice}\n/**\n${seeCommentBlockLines()}\n */\nconst ${methodName} = Symbol();\n\nexport default ${methodName};\n`;
  }

  for (const [methodName, typeNames] of typeNamesByMethodName) {
    const path = `./${methodName}.ts`;
    const data = symbolFileData(methodName, [...typeNames]);
    await updateTextFile(path, data);
  }
}

/**
 * @param typeNamesByMethodName
 */
async function writeTypeMethodFiles(
  typeNamesByMethodName: Map<string, Set<string>>,
) {
  function typeMethodFileData(methodName: string, typeName: string) {
    function imports() {
      let result = "";
      // todo: load supplement augmentations conditionally
      switch (typeName) {
        case "TypedArray":
        case "TypedArrayConstructor":
        case "Queue":
        case "QueueConstructor":
        case "Deque":
        case "DequeConstructor":
          result += `import ${typeName} from "../${typeName}.ts";\n\n`
            .replaceAll(/\BConstructor\b/g, "");
          break;
        case "Iterator":
        case "Generator":
        case "AsyncIterator":
        case "AsyncGenerator":
          result += `import * as ${typeName} from "../${typeName}.ts";\n\n`;
          break;
      }
      result += `import key from "../${methodName}.ts";\n`;
      result += `import value from "./methods/${methodName}.ts";\n`;
      return result;
    }

    function declareAugmentation() {
      function isGlobal() {
        switch (typeName) {
          case "Queue":
          case "Deque":
            return false;
          default:
            return true;
        }
      }

      function typeNameArray() {
        switch (typeName) {
          case "Array":
          case "Set":
          case "Map":
            return [typeName, `Readonly${typeName}`];
          default:
            return [typeName];
        }
      }

      function typeNameGenerics(typeName: string) {
        switch (typeName) {
          case "Array":
          case "AsyncIterator":
          case "Iterator":
          case "ReadonlyArray":
          case "ReadonlySet":
          case "Set":
          case "WeakSet":
          case "Queue":
          case "Deque":
            return "<T>";
          case "Map":
          case "ReadonlyMap":
          case "WeakMap":
            return "<K, V>";
          default:
            return "";
        }
      }

      return `declare ${isGlobal() ? "global" : `module "../${typeName}.ts"`} {
${
        typeNameArray()
          .map((typeName) =>
            `  ${
              isGlobal() ? "interface" : "export default interface"
            } ${typeName}${
              typeNameGenerics(typeName)
            } {\n    [key]: typeof value;\n  }`
          )
          .join("\n")
      }
}
`;
    }

    function augmentation() {
      return `Object.defineProperty(${target(typeName)}, key, { value });\n`;

      function target(typeName: string) {
        switch (typeName) {
          case "Math":
            return typeName;
          default:
            if (typeName.endsWith("Constructor")) {
              return typeName.slice(0, -"Constructor".length);
            }
            return `${typeName}.prototype`;
        }
      }
    }

    return `${autogeneratedNotice}\n${imports()}\n${declareAugmentation()}\n${augmentation()}\n`;
  }

  for (const [methodName, typeNames] of typeNamesByMethodName) {
    for (const typeName of typeNames) {
      const path = `${typeName}/${methodName}.ts`;
      const data = typeMethodFileData(methodName, typeName);
      await updateTextFile(path, data);
    }
  }
}

{
  const typeNamesByMethodName = await loadTypeNamesByMethodName();

  await writeSymbolFiles(typeNamesByMethodName);
  await writeTypeMethodFiles(typeNamesByMethodName);
}

Deno.exit(0);

await writeRootMethodFiles();

async function writeRootMethodFiles() {
  function rootMethodFileData(methodName: string, typeNames: string[]) {
    function reexportDefault() {
      return `export { default } from "./symbols/${methodName}.ts";\n`;
    }

    function imports() {
      function importStatement(typeName: string) {
        return `import "./${typeName}/${methodName}.ts";`;
      }

      return `${typeNames.map(importStatement).join("\n")}\n`;
    }

    return `${autogeneratedNotice}\n${reexportDefault()}\n${imports()}`;
  }

  for (const [methodName, typeNames] of typeNamesByMethodName) {
    const path = `${methodName}.ts`;
    const data = rootMethodFileData(methodName, [...typeNames]);
    await updateTextFile(path, data);
  }
}

// todo: create watch mode

// for await (const { kind, paths } of Deno.watchFs(".", { recursive: true })) {
//   for (const path of paths) {
//     if (!/\/methods\/[a-zA-Z]+.ts$/.test(path)) continue;
//     console.log(kind, path);
//   }
// }
